## Introduction to Authentication

Authentication is verifying the identity of users, devices, systems, and any particular resource in the network. In other words, before allowing access to anything we must provide something that proves ourselves.

There are three ways for authentication and they are the following:

- **Something you know**: In which user or entity provides something that they only know like passwords or security questions etc.
- **Something you have**: In which the user has any physical thing that proves his identity and only that user should have it i.e Identity card, Security token, Mobile phone to get a secret phrase or something.
- **Something you are**: In which users prove their identity by their genetic things like a fingerprint, retina scan, etc.

## Introduction to Authorization

Whenever a user or entity is authenticated the next thing start is an authorization. In Authorization, we determine its permission, rights, and total access in the system. Authentication is important for ensuring the security and integrity of sensitive data and resources.

There are several approaches for Authorization:

- Role Based Access Control (RBAC)
- Attribute Based Access Control (ABAC)
- Mandatory Access Control (MAC)

These are approaches we can use for authorization we cannot go into detail here but I recommend you do further reading.

## How do Authentication Vulnerabilities arise

Authentication issues arise in many ways such as logical flaws, failure to limit no of requests per second, software flaws, and human errors.

In the context of Web Applications authentication flaws are mostly due to logic flaws and failure to adequately protect against brute forces attacks (limit the number of requests per second). 

## Type of Authentication Vulnerabilities

- Brute-force Attack
- Man-in-the-Middle (MitM) Attack
- Phishing
- Password Guessing and Breach Passwords

## Impact of Authentication Vulnerabilities

The impact of authentication vulnerabilities can be very severe. Once an attacker has either bypassed authentication or has brute-forced their way into another user's account, they have access to all the data and functionality that the compromised account has. If they are able to compromise a high-privileged account, such as a system administrator, they could take full control over the entire application and potentially gain access to internal infrastructure.

Even compromising a low-privileged account might still grant an attacker access to data that they otherwise shouldn't have, such as commercially sensitive business information. Even if the account does not have access to any sensitive data, it might still allow the attacker to access additional pages, which provides a further attack surface. Often, certain high-severity attacks will not be possible from publicly accessible pages, but they may be possible from an internal page.

## Best Practice of Prevention

- Use a Strong Password and change it timely
- Use Multifactor Authentication
- Prevent username enumeration
- Prevent Brute force attacks

These are some common practices that should be implemented properly and there are some other practices as well that I recommend to research your own and implement properly.


## Checking for Authentication Flaws

In the context of Web Applications, there are some points where authentication vulnerabilities may occur. Some vulnerabilities are broadly applicable across all of these contexts, whereas others are more specific to the functionality provided.

Some common points we should check are the following.

- Password Based logins
- Multi-factor-based authentication
- Other authentication mechanisms

## Vulnerabilities in Password-Based login

Websites use password-based logins in which they provide a username and password and if both are correct users get access to their account if not they didn't get any access. In the password-based login method, they use the **Something you know** method of authentication and if anyone knows the username and password they get access. In there we try to get that username or password by using various attacks.

### **Brute force Attacks**

A brute force attack is a type of attack in which an attacker makes so many requests to the server that use different usernames and passwords and sees any different response from the server for a successful attack.

Brute-forcing is not always just a case of making completely random guesses at usernames and passwords. By also using basic logic or publicly available knowledge, attackers can fine-tune brute-force attacks to make much more educated guesses. This considerably increases the efficiency of such attacks. Websites that rely on password-based login as their sole method of authenticating users can be highly vulnerable if they do not implement sufficient brute-force protection.

- **Brute forcing Usernames**

Usernames that follow a recognizable pattern, like an email address format, are easy to guess. Even high-privileged accounts may use predictable usernames, such as "admin".
When auditing, check if potential usernames are disclosed publicly, like in user profiles or HTTP responses. Sometimes high-privileged user email addresses are disclosed in responses. the website may use email instead of usernames so you may also find emails from social media platforms or any publicly disclosed data you can also try some basic email patterns like `[first].[plast]@example.com`

- **Brute forcing password**

Passwords can similarly be brute-forced, with the difficulty varying based on the strength of the password. Many websites adopt some form of password policy, which forces users to create high-entropy passwords that are, theoretically at least, harder to crack using brute force alone. But we can use some password wordlist or uses human behavior to make our own list to guess the password.

## Flawed brute-force protection

To succeed in brute force attacks we have to make so many failed requests to the server. So this attack is only possible if we can able to make all those requests so the website uses a brute forces protection system that will **block the IP address of remote user after some failed attempt** or they may lock the **user account in which brute force attack is performed**.

Both approaches offer varying degrees of protection, but neither is invulnerable, especially if implemented using flawed logic.

For example, you might sometimes find that your IP is blocked if you fail to log in too many times. In some implementations, the counter for the number of failed attempts resets if the IP owner logs in successfully. This means an attacker would simply have to log in to their own account every few attempts to prevent this limit from ever being reached.

In this case, merely including your own login credentials at regular intervals throughout the wordlist is enough to render this defense virtually useless.

Another way websites try to prevent brute-force attacks is through user rate limiting. In this case, making too many login requests within a short period of time causes your IP address to be blocked. Typically, the IP can only be unblocked in one of the following ways:

-   Automatically after a certain period of time has elapsed
-   Manually by an administrator
-   Manually by the user after successfully completing a CAPTCHA

## Vulnerabilities in Multi-factor Authentication

Multi-factor authentication (MFA) is more secure than single-factor authentication, but poorly implemented MFA can be beaten or bypassed. MFA typically requires users to enter a password and a temporary verification code from a physical device they possess. MFA is only effective if it verifies multiple different factors, not the same factor in two different ways. For example, email-based 2FA is not true MFA because it relies on verifying the knowledge authentication factor twice.

 If the user is first prompted to enter a password, and then prompted to enter a verification code on a separate page, the user is effectively in a "logged in" state before they have entered the verification code. In this case, it is worth testing to see if you can directly skip to "logged-in only" pages after completing the first authentication step. Occasionally, you will find that a website doesn't actually check whether or not you completed the second step before loading the page.

## Flawed two-factor verification logic

Sometimes flawed logic in two-factor authentication means that after a user has completed the initial login step, the website doesn't adequately verify that the same user is completing the second step.

For example, the user logs in with their normal credentials in the first step as follows:

```
POST /login-steps/first HTTP/1.1
Host: vulnerable-website.com
...
username=carlos&password=qwerty
```

They are then assigned a cookie that relates to their account, before being taken to the second step of the login process:

```
HTTP/1.1 200 OK
Set-Cookie: account=carlos

GET /login-steps/second HTTP/1.1
Cookie: account=carlos
```

When submitting the verification code, the request uses this cookie to determine which account the user is trying to access:

```
POST /login-steps/second HTTP/1.1 
Host: vulnerable-website.com 
Cookie: account=carlos
...
verification-code=123456
```

In this case, an attacker could log in using their own credentials but then change the value of the `account` cookie to any arbitrary username when submitting the verification code.

```
POST /login-steps/second HTTP/1.1
Host: vulnerable-website.com
Cookie: account=victim-user
...
verification-code=123456
```

This is extremely dangerous if the attacker is then able to brute-force the verification code as it would allow them to log in to arbitrary users' accounts based entirely on their usernames. They would never even need to know the user's password.

## Brute-forcing 2FA verification codes

As with passwords, websites need to take steps to prevent brute-forcing of the 2FA verification code. This is especially important because the code is often a simple 4 or 6-digit number. Without adequate brute-force protection, cracking such a code is trivial.

Some websites attempt to prevent this by automatically logging a user out if they enter a certain number of incorrect verification codes. This is ineffective in practice because an advanced attacker can even automate this multi-step process.

## Vulnerabilities in other authentication mechanisms

Sometimes websites provide other functionality like forgetting passwords. This functionality often got vulnerabilities that could lead to authentication issues.

Websites usually take care to avoid well-known vulnerabilities in their login pages. But it is easy to overlook the fact that you need to take similar steps to ensure that related functionality is equally as robust. This is especially important in cases where an attacker is able to create their own account and, consequently, has easy access to study these additional pages.

## Keeping the user logged in

"Remember me" functionality is a common feature in websites, which allows users to stay logged in after closing their browser session. Websites generate a "remember me" token that is stored in a persistent cookie, but some generate it based on predictable values such as the username and timestamp, or even the password. If an attacker can study their own cookie, they may be able to deduce the formula and brute-force other users' cookies to gain access to their accounts. Even if the cookie is encrypted using proper encryption with a one-way hash function, it is not completely secure if the hashing algorithm is easily identifiable and no salt is used. This can be used to bypass login attempt limits.

If an attacker is not able to make its own cookie it may be able to get that token by using attacks like XSS. In some rare cases, it may be possible to obtain a user's actual password in cleartext from a cookie, even if it is hashed. Hashed versions of well-known password lists are available online, so if the user's password appears in one of these lists, decrypting the hash can occasionally be as trivial as just pasting the hash into a search engine. This demonstrates the importance of salt-ineffective encryption.

## Changing user password

Password changed functionality often have vulnerabilities that attacker can use to change other users' passwords.
